{-Legacy Code-}

-- {-step 0 -}
-- query ::D.PreferenceMap -> D.Language -> D.Argument -> Defeater 
-- query pm lang incArgu = 
--     let 
--         initBoard = initialBoard incArgu 
--     in chainConstruction pm lang initBoard 
-- 
-- chainConstruction ::D.PreferenceMap -> D.Language -> Board -> Defeater 
-- chainConstruction pm lang step1Board = 
--     case defeatCheck pm lang step1Board of                          -- step 2 : check defeat  : update 'lucky' & 'waiting'
--         Right p -> warranted p                                  -- step 5: return warranted defeater  
--         Left step2Board -> 
--             case pathSelection' step2Board of                -- step 3: path selection  : update 'lucky' , set 'base'
--                 Just (base,step3Board) -> 
--                     let 
--                         luckyExtend= augConstruction lang base   -- step 4: new lucky set 
--                         step3Lucky = lucky step3Board
--                         step4Board = step3Board{lucky=step3Lucky++luckyExtend}
--                     in chainConstruction pm lang step4Board
--                 Nothing -> 
--                     case luckyEmpty pm lang step2Board of           -- step 6: update 'waiting' for sure , update 'lucky' (step 9) or 'futile' (step 7)
--                         Right unw -> unw                        -- step 8
--                         Left step6Board -> chainConstruction pm lang step6Board
-- 
-- {- 2
-- - Given Board from step 1
--     - Check 'lucky': If any unseen inc-defeater found for each path: 
--         - include all newly defeated target to seen
--         - Attaches the inc-defeater to related Path , move this PathRecord to 'waiting'
--         - If path has old related defeater(much be unwarranted defeater), then remove this old defeater and attach this new in-defeater. 
--             - a SearchRecord turns to be a PathRecord
--     - Check if any SearchRecord in 'lucky' contains complete Path. 
--         - Yes: go to 5 
--             - Exit : Pass the complete Path Record to 5 and get return result 
--         - No : go to 3 
--             - Continue construction
-- Notes:
--     1. when detecting one search record in lucky has new in-defeater, remove old fail-defeater, then put to tmpWaiting
--         inc-Argument defeat path
--     2. select one lucker from possibly many in lucky
-- -}
-- defeatCheck :: D.PreferenceMap ->  D.Language -> Board -> Either Board SearchRecord
-- defeatCheck pm lang board@Board{..}= 
--     let 
--         (newWaiting, newSeen, newLucky) = defeaterFilter' pm lang seen lucky    -- note 1
--     in 
--         if checkLuckyComplete newLucky 
--             then 
--                 Right $ selectOneLucker newLucky                            -- note 2
--             else 
--                 Left $ board{lucky = newLucky,waiting = waiting ++ newWaiting, seen=newSeen}
-- 
-- -- | Check lucy set one by one
-- -- the one with defeater move to wait, and add defeat target to seen. 
-- -- the one with no defeater stays in lucy
-- defeaterFilter' :: D.PreferenceMap -> D.Language ->  D.Language -> SearchRecords-> (PathRecords, D.Language, SearchRecords)
-- defeaterFilter' pm _    seen [] = ([],seen,[])
-- defeaterFilter' pm lang seen (r:rs) = 
--     let 
--         (re, newSeen)  = testLucker' pm lang seen r 
--         (newwait, ss , nlucy) = defeaterFilter' pm lang newSeen rs 
--     in 
--         case re of 
--             Right sr -> (newwait,ss, sr : nlucy)
--             Left pr -> (pr : newwait, ss, nlucy)
--     where
--         testLucker' ::D.PreferenceMap -> D.Language -> D.Language -> SearchRecord -> (Either PathRecord SearchRecord, D.Language)
--         testLucker' pm  lang seen sr@(p,_) = 
--             let 
--                 rebutters = selectRebutters lang seen p 
--                 undercutters = selectUndercutters lang seen p 
--                 defeaters = selectDefeaters' pm lang p rebutters undercutters
--             in 
--                 if null defeaters 
--                     then (Right sr, seen)
--                     else 
--                         let 
--                             newSeen = updateSeen seen defeaters 
--                             newPathRecord = createPathRecord' lang p defeaters
--                         in (Left newPathRecord, newSeen )
--
-- luckyEmpty ::D.PreferenceMap -> D.Language -> Board -> Either Board Defeater 
-- luckyEmpty pm lang board@Board{..} = case waiting of 
--     [] -> Right $ unwarranted futile 
--     _ -> let 
--             ((p,incArgument), tmpWaiting) = selectionTwo' waiting 
--             result = query pm lang incArgument 
--          in case tellQuery result of 
--                 Warranted -> 
--                     let 
--                         newBoard = waitingToFutile (p,result) tmpWaiting board
--                     in  luckyEmpty pm lang newBoard
--                 Unwarranted -> 
--                     let 
--                         newBoard = survived (p,result) tmpWaiting board
--                     in  Right $ chainConstruction pm lang newBoard 

-- createPathRecord' :: D.Language -> D.Path ->  D.Language -> PathRecord
-- createPathRecord' lang p defeaters = (p, initIncArgument' lang defeaters)

-- -- | TODO: Rebuters winner path need to be preserved
-- selectDefeaters' ::D.PreferenceMap -> D.Language -> D.Path -> D.Language -> D.Language -> D.Language
-- selectDefeaters' _  _    _     [] uns@(x:_)= uns 
-- selectDefeaters' pm lang p   res uns = checkRebutters lang p res ++ uns
--     where 
--         checkRebutters :: D.Language -> D.Path -> D.Language -> D.Language 
--         checkRebutters _    _ [] = []
--         checkRebutters lang p (u:us) = 
--             case lastLinkChecker p [M.neg u] of 
--                 (False,_) -> checkRebutters lang p us 
--                 (True, defRules) -> 
--                     let 
--                         attackDefs = attackerLastScan lang u 
--                         ordPrem = ord pm 
--                     in 
--                         if any (`ordPrem` defRules) attackDefs 
--                         then u : checkRebutters lang p us 
--                         else checkRebutters lang p us 

-- -- | TODO: 构建 defeater 的 path 应该把有效的保留下来， 不同长度的也可以完美应对，因为其实每次的base都只有一个，所以无所谓的.
-- --  and this is acutally a great optimization point. 
-- attackerLastScan :: D.Language -> D.Literal -> [D.Language]
-- attackerLastScan lang l = 
--     let 
--         initArg = initIncArgument' lang [l]  
--     in  completeLastChecker lang initArg 

-- initIncArgument' :: D.Language -> D.Language -> D.Argument 
-- initIncArgument' lang props = 
--     let 
--         rulesSet = concludeBy' lang <$> props 
--     in  [[p] |p <- foldr createParallel [[]] rulesSet]
--     where 
--         createParallel :: [a] -> [[a]] -> [[a]] 
--         createParallel paths ls = do 
--                         pa <- paths
--                         a <- ls 
--                         pure $  pa:a         


-- concludeBy' :: D.Language -> D.Literal -> D.Language 
-- concludeBy' lang l = [r | r <- lang, D.conC r == l ]

-- agu' :: D.Language  -> D.Argument -> D.Argument 
-- agu' lang argument =
--     let  
--         arguments = pathExtend' lang <$> argument 
--     in concat arguments 

-- pathExtend' :: D.Language -> D.Path -> D.Argument 
-- pathExtend' lang path = 
--     let 
--         rules = last path 
--         bodies = concat $ D.body <$> rules 
--     in 
--         if null bodies 
--             then [path]
--             else 
--                 let  
--                     supportRules = concludeBy' lang <$> bodies 
--                     parallelPathSection = foldr parallel [[]] supportRules
--                     newArgument = do 
--                             pathSection <- parallelPathSection
--                             pure $ path ++ [pathSection] 
--                 in newArgument
--     where 
--         parallel :: [a] -> [[a]] -> [[a]] 
--         parallel paths ls = do 
--                 pa <- paths
--                 a <- ls 
--                 pure $  pa:a  

-- augConstruction :: D.Language -> SearchRecord -> SearchRecords
-- augConstruction lang (p,defeater) = 
--     let 
--         tmpArg = pathExtend' lang p 
--     in (,defeater) <$> tmpArg 

-- completeLastChecker :: D.Language -> D.Argument -> [D.Language]
-- completeLastChecker _   []        = [] 
-- completeLastChecker lang argument = 
--     let
--         a = do 
--             p <- argument 
--             let c = lastLinkChecker p lang 
--             guard $ fst c 
--             pure $ snd c 
--         b = do 
--             p <- argument 
--             let c = lastLinkChecker p lang
--             guard $ not (fst c) 
--             pure p 
--     in a ++ completeLastChecker lang (agu' lang b)

-- pathSelection' :: Board -> Maybe (SearchRecord, Board)
-- pathSelection' board@Board{..} = case lucky of 
--     [] -> Nothing 
--     _ -> Just (base, newBoard)
--     where 
--         (base, newlucky) = selectionOne' lucky
--         newBoard = board{lucky=newlucky}
-- 
-- selectionOne' :: SearchRecords -> (SearchRecord, SearchRecords)
-- selectionOne' srs =
--     let 
--         sortByLength = sortBy (flip compare `on` (length . fst)) srs 
--         sortByDefeasible = sortBy (flip compare `on` (length . getDef . fst)) srs 
--     in (head sortByDefeasible, tail sortByDefeasible)  
--     where 
--         getDef :: D.Path -> D.Language 
--         getDef p = 
--             let 
--                 rules = concat p 
--             in [r | r<-rules, D.imp r == M.D]
-- 

-- selectionTwo' :: PathRecords -> (PathRecord, PathRecords)
-- selectionTwo' prs = 
--     let 
--         sortByLength = sortBy (flip compare `on` (length . fst)) prs  
--         sortByDefeasible = sortBy (flip compare `on` (length . getDef . fst)) prs 
--     in (head sortByDefeasible, tail sortByDefeasible)  
--     where 
--         getDef :: D.Path -> D.Language 
--         getDef p = 
--             let 
--                 rules = concat p 
--             in [r | r<-rules, D.imp r == M.D]
--             